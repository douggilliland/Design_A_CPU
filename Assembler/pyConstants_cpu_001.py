# pyConstants_cpu_001
# Create constants fileAssemble code for CPU
# 
# CPU is at
# 	https://github.com/douggilliland/Design_A_CPU/tree/main
#
# Input File
#	File named: fileName.csv
# 	Input file is tightly constrained in CSV file
# 	Input File Header has to be -
#		['LABEL', 'STRING']
# 
# Output files
# 	.mif file - Quartus II ROM Memory Initialization File
#	.lst file - Listing file (with addresses)
#
# Error Messages
#	Error messages are pretty rudimentary.
#	Error messages are printed to the command window.
#	The line with the error is printed as a list of the line.
#	Missing labels are presented as a message.
# 	Only one error at a time is presented.
#

import binascii
import csv
import string
import os
import sys
from sys import version_info

import time
from datetime import date

from dgProgDefaultsTk import *
from dgReadCSVtoListTk import *
from dgWriteListtoCSVTk import *

from tkinter import filedialog
from tkinter import *
from tkinter import messagebox

defaultPath = '.'

labelsList = {}
program = []
annotatedSource = []

class ControlClass:
	"""Methods 
	"""
	
	def doConvert(self):
		"""The code that calls the other code
		"""
		global defaultPath
		global labelsList
		global program
		global annotatedSource
		defaultParmsClass = HandleDefault()
		defaultParmsClass.initDefaults()
		defaultPath = defaultParmsClass.getKeyVal('DEFAULT_PATH')
		# print '(doConvert): defaultPath',defaultPath
		myCSVFileReadClass = ReadCSVtoList()	# instantiate the class
		myCSVFileReadClass.setVerboseMode(False)	# turn on verbose mode until all is working 
		myCSVFileReadClass.setUseSnifferFlag(True)
		doneReading = False
		inList = myCSVFileReadClass.findOpenReadCSV(defaultPath,'Select CONSTS (CSV) File')	# read in TSV into list
		if inList == []:
			errorDialog("doConvert): No file selected")
			return
		defaultPath = myCSVFileReadClass.getLastPath()
		defaultParmsClass.storeKeyValuePair('DEFAULT_PATH',defaultPath)
		if inList[0] != ['LABEL', 'STRING']:
			print('header :',inList[0])
			errorDialog('Header does not match expected values\nSee command window\nProbably needs the version number added to the final column header')
			assert False,'header does not match expected values'
		else:
			print('header ok')
		inFileName = myCSVFileReadClass.getLastPathFileName()
		addressTable = self.makeAddressTable(inList)
		print("addressTable",addressTable)
		longOutStr = self.makeOutStr(inList)
		print("longOutStr\n",longOutStr)
		outAsciiVals = self.makeAsciiVals(longOutStr)
		print("outAsciiVals",outAsciiVals)
		contsAsciiTable = self.makeACSIITable(outAsciiVals)
		print("contsAsciiTable",contsAsciiTable)
		print('inFileName',inFileName)
		self.outStuff(inFileName,contsAsciiTable,addressTable)
		infoBox("Complete")
			
	def makeACSIITable(self,outAsciiVals):
		outValStrs = []
		for char in outAsciiVals:
			outValsLine = ''
			
			if char == [0,0]:
				outValsLine += '0'
				outValsLine += '0'
			else:
				for pair in char:
					outValsLine += chr(pair)
			outValStrs.append(outValsLine)
		return outValStrs
	
	def ascii_to_hex(self,ascii_char):
		pos1 = binascii.hexlify(str(ascii_char).encode())
		hexStr = []
		hexStr.append(pos1[0])
		hexStr.append(pos1[1])
		return hexStr

	def makeAsciiVals(self, longOutStr):
		outAsciiVals = []
		for char in longOutStr:
			if char != '~':
				hex_str = self.ascii_to_hex(char)
				outAsciiVals.append(hex_str)
			else:
				outAsciiVals.append([0,0])
		return outAsciiVals
	
	def makeAddressTable(self, inList):
		addressTable = []
		address = 0
		print("makeAddressTable: inList[1:]",inList[1:])
		for line in inList[1:]:
			addressTable.append([line[0],address])
			address += len(line[1]) + 1
		return addressTable

	def makeOutStr(self, inList):
		outStr = ''
		for line in inList[1:]:
			for char in line[1]:
				outStr += char
			outStr += '~'
		return outStr

	def outStuff(self,inFileName,contsAsciiTable,addressTable):
		"""
		[['LABEL', 'OPCODE', 'VAL4', 'VAL8', 'COMMENT'], ['INIT', 'NOP', '', '', ''], ['', 'LRI', '0X00', '0X01', 'LOAD START CMD'], ['', 'LRI', '0X01', '0X40', 'LOAD SLAVE ADDR<<1, WRITE'], ['', 'LRI', '0X02', '0X00', 'LOAD IDLE CMD'], ['', 'LRI', '0X03', '0X00', 'LOAD IODIRA REGISTER_OFFSET'], ['', 'LRI', '0X04', '0XFF', 'LOAD IODIRA_ALL_INS'], ['', 'IOW', '0X00', '0X00', 'ISSUE START CMD'], ['', 'IOW', '0X01', '0X00', 'ISSUE SLAVE ADDR<<1, WRITE'], ['', 'IOW', '0X02', '0X00', 'ISSUE IDLE CMD'], ['', 'IOW', '0X03', '0X00', 'ISSUE IODIRA REGISTER_OFFSET'], ['', 'IOW', '0X04', '0X00', 'ISSUE IODIRA_ALL_INS'], ['LDST000', 'IOR', '0X05', '0X00', 'READ STATUS'], ['', 'ARI', '0X05', '0X01', 'BUSY BIT'], ['', 'BNZ', '', 'LDST000', 'LOOP UNTIL NOT BUSY'], ['SELF', 'JMP', 'SELF', '', '']]
		"""
		outFilePathName = inFileName[0:-4] + '_const.mif'
		print('outFilePathName',outFilePathName)
		# for row in sourceFile:
			# print(row)
		outList = []
		outStr = '-- File: ' + outFilePathName
		outList.append(outStr)
		outList.append('-- Generated by pyAssemble_cpu_001.py')
		outList.append('-- ')
		outLen = 0
		for row in contsAsciiTable:
			outLen += 1
		outStr = 'DEPTH = '+ str(outLen) + ';'
		outList.append(outStr)
		outList.append('WIDTH = 8;')
		outList.append('ADDRESS_RADIX = DEC;')
		outList.append('DATA_RADIX = HEX;')
		outList.append('CONTENT BEGIN')
		lineCount = 0
		addrCount = 0
		outStr = ''
		for row in contsAsciiTable:
			if lineCount == 0:
				outStr += str(addrCount)
				outStr += ': '
			outStr += row
			if lineCount < 7:
				outStr += ' '
			lineCount += 1
			addrCount += 1	
			if lineCount == 8:
				lineCount = 0
				outStr += ';'
				outList.append(outStr)
				outStr = ''
		
		outList.append('END;')
		# for line in outList:
			# print(line)

		F = open(outFilePathName, 'w')
		for row in outList:
			F.writelines(row+'\n')
		F.close()
		
		outFilePathName = outFilePathName[0:-4] + '.lst'
		F = open(outFilePathName, 'w')
		address = 0
		print("addressTable",addressTable)
		for row in addressTable:
			outStr = ''
			label = row[0]
			addrOff = hex(row[1])
			if len(addrOff) == 3:
				addrOff = '0x0' + addrOff[2]
			print(label,addrOff)
			outStr = label + ' ' + addrOff + '\n'
			F.writelines(outStr)
			address += 1
		F.close()

		
	
class Dashboard:
	def __init__(self):
		self.win = Tk()
		self.win.geometry("320x240")
		self.win.title("pyConstants-cpu001")

	def add_menu(self):
		self.mainmenu = Menu(self.win)
		self.win.config(menu=self.mainmenu)

		self.filemenu = Menu(self.mainmenu, tearoff=0)
		self.mainmenu.add_cascade(label="File",menu=self.filemenu)

		self.filemenu.add_command(label="Open consts file",command=control.doConvert)
		self.filemenu.add_separator()
		self.filemenu.add_command(label="Exit",command=self.win.quit)

		self.win.mainloop()
		
if __name__ == "__main__":
	if version_info.major != 3:
		errorDialog("Requires Python 3")
	control = ControlClass()
	x = Dashboard()
	x.add_menu()
